//--------------------------------------
//--- 010 Editor v6.0.1 Binary Template
//
// File:
// Author:
// Revision:
// Purpose:
//--------------------------------------
typedef WORD uint16_t; 
typedef DWORD uint32_t; 
typedef QWORD uint64_t; 
typedef unsigned char uint8_t;


struct MappingHeader {
    DWORD dwStartSignature;
    DWORD dwVersion;
};

struct MappingXPHeader {
    struct MappingHeader sHeader;
    DWORD         dwPhysicalPages;
    DWORD         dwMappingEntries;
};

struct MappingWin7Header {
    struct MappingHeader sHeader;
    DWORD dwFirstID;
    DWORD dwSecondID;
    DWORD dwPhysicalPages;
    DWORD dwMappingEntries;
};

struct MappingEntry {
    DWORD dwPageNumber;
    DWORD dwPageCRC;
    DWORD dwFreeSpace;
    DWORD dwUserData;
    DWORD dwFirstID;
    DWORD dwSecondID;
};

struct MappingWin7 {
    struct MappingWin7Header header;
    struct MappingEntry entries[header.dwMappingEntries];
    uint32_t numFreeDwords;
    uint32_t free[numFreeDwords];
    uint32_t footer;
};

struct MappingFileWin7 {
    struct MappingWin7 objectsMap;
    struct MappingWin7 indexMap;
    uint32_t isDirty;
};

struct MappingXP {
    struct MappingXPHeader header;
    DWORD entries[header.dwMappingEntries];
    uint32_t numFreeDwords;
    uint32_t free[numFreeDwords];
    uint32_t footer;
};

struct MappingFileXP {
    struct MappingXP objectsMap;
    struct MappingXP indexMap;
};

struct Toc {
  uint32 RecordID;
  uint32 Offset;
  uint32 Size;
  uint32 Crc32;
};

struct ObjData {
  local QWORD offset = 0;
  local DWORD tocsize = 0;
  while (1) {
    if (ReadQuad(offset) == 0x0) {
      tocsize = offset / sizeof(struct Toc);
      break;
    }
    offset += sizeof(struct Toc);  
  }
  struct Toc tocs[tocsize];
};

struct Object {
    uint32_t nameLen;
    wchar_t name[nameLen];
    uint64_t unk0;
    uint32_t bufLen;
    //uint8_t buf[bufLen - sizeof(bufLen)];
    uint8_t unk1[0xE];
    char nameA[ReadStringLength(FTell())];
    uint32_t unk2; // 0x0F
    uint32_t unk3; // 0x04
    uint32_t unk4; // 0x01
    uint32_t unk5; // 0x0D
    uint32_t unk6;

};

enum {
  PAGE_TYPE_UNK        = 0x0000,
  PAGE_TYPE_ACTIVE     = 0xACCC,
  PAGE_TYPE_DELETED    = 0xBADD,
  PAGE_TYPE_ADMIN      = 0xADDD
};

struct PageHeader {
    uint32_t Sig;
    uint32_t LogicalId;
    uint32_t Zero1;
    uint32_t Zero2;
    uint32_t RecordCount;
};

struct BtrPage {
    struct PageHeader header;
    uint32_t current[header.RecordCount];
    uint32_t children[header.RecordCount + 1];
    uint16_t keys[header.RecordCount];
    uint16_t stringDefTableSize;
    uint16_t stringDefTable[stringDefTableSize];
    uint16_t stringPartTableSize;
    uint16_t stringPartTable[stringPartTableSize + 1];
};

struct WmiString {
    uint8_t zero;
    char s[ReadStringLength(FTell())];
};

struct ObjectClassDefinition {
    uint32_t wnameLen;
    wchar_t wname[wnameLen];
    FILETIME ts;
    uint8_t unk0;
    uint32_t unk1;
    uint32_t offsetClassName;
    uint32_t unk2;
    uint32_t unk3;
    if (wnameLen > 0) {
        struct WmiString aname;
        uint32_t unk4;
    }
    struct {
        uint32_t qualifierListSize;
        uint8_t qualifierListData[qualifierListSize - sizeof(qualifierListSize)];
    } qualifierList;
    uint32_t numProperties;
    struct {
        uint32_t nameRef;
        uint32_t defRef;
    } propertyRefs[numProperties];
};

enum <uint8_t> CIM_TYPES {
    CIM_TYPE_LANGID = 0x3,
    CIM_TYPE_REAL32 = 0x4,
    CIM_TYPE_STRING = 0x8,
    CIM_TYPE_BOOLEAN = 0xB,
    CIM_TYPE_UINT8 = 0x11,
    CIM_TYPE_UINT16 = 0x12,
    CIM_TYPE_UINT32 = 0x13,
    CIM_TYPE_UINT64 = 0x15,
    CIM_TYPE_DATETIME = 0x65
};

struct CimType {
    uint8_t type;
    uint8_t isArray;
    uint8_t unk0;
    uint8_t unk1;
};

struct Qualifier {
    uint32_t keyReference;
    uint8_t unk0;
    struct CimType valueType;
    switch (valueType.type) {
    case CIM_TYPE_REAL32:
        float value;
        break;
    case CIM_TYPE_LANGID:
        uint32_t value;
        break;
    case CIM_TYPE_STRING:
        uint32_t value;
        break;
    case CIM_TYPE_BOOLEAN:
        uint16_t value;
        break;
    case CIM_TYPE_UINT8:
        uint8_t value;
        break;
    case CIM_TYPE_UINT16:
        uint16_t value;
        break;
    case CIM_TYPE_UINT32:
        uint32_t value;
        break;
    case CIM_TYPE_UINT64:
        uint64_t value;
        break;
    case CIM_TYPE_DATETIME:
        FILETIME value;
        break;
    }
};

struct PropertyDef {
    struct CimType type;
    uint16_t unk0;
    uint32_t unk1;
    uint32_t unk2;
    struct {
        uint32_t qualifierListSize;
        uint8_t qualifierListData[qualifierListSize - sizeof(qualifierListSize)];
    } qualifierList;
};


struct InstanceData {
    wchar_t classNameHash[0x40];
    FILETIME ts1;
    FILETIME ts2;
    uint32_t dataLen;
    //uint8_t data[dataLen - sizeof(dataLen)];
    uint8_t unk0[0x6];
    struct {
        //uint8_t consumerToc[0xD];
        uint32_t strRef;
        //uint8_t unk1[0x5];
    } toc;
    uint32_t nextSize;
    

    uint32_t dataSize;
};

//FSeek(GetCursorPos());

//struct MappingFileXP f;
//struct MappingFileWin7 f;
//struct ObjData o;


//struct Object o;

//FSeek(GetCursorPos());
//struct BtrPage ph;

struct ObjectClassDefinition ocd;
//struct ObjectField f;
//struct Qualifier q;

//struct InstanceData i;

//struct PropertyDef pd;